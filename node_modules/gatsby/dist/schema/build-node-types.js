"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

const _ = require(`lodash`);

const _require = require(`graphql`),
      GraphQLObjectType = _require.GraphQLObjectType,
      GraphQLNonNull = _require.GraphQLNonNull,
      GraphQLID = _require.GraphQLID,
      GraphQLList = _require.GraphQLList;

const tracer = require(`opentracing`).globalTracer();

const apiRunner = require(`../utils/api-runner-node`);

const _require2 = require(`./infer-graphql-type`),
      inferObjectStructureFromNodes = _require2.inferObjectStructureFromNodes;

const _require3 = require(`./infer-graphql-input-fields-from-fields`),
      inferInputObjectStructureFromFields = _require3.inferInputObjectStructureFromFields;

const _require4 = require(`./infer-graphql-input-fields`),
      inferInputObjectStructureFromNodes = _require4.inferInputObjectStructureFromNodes;

const _require5 = require(`./node-interface`),
      nodeInterface = _require5.nodeInterface;

const _require6 = require(`../db/nodes`),
      getNodes = _require6.getNodes,
      getNode = _require6.getNode;

const pageDependencyResolver = require(`./page-dependency-resolver`);

const _require7 = require(`./types/type-file`),
      setFileNodeRootType = _require7.setFileNodeRootType;

const _require8 = require(`./data-tree-utils`),
      clearTypeExampleValues = _require8.clearTypeExampleValues;

const _require9 = require(`../db/nodes`),
      runQuery = _require9.runQuery;

module.exports =
/*#__PURE__*/
function () {
  var _ref = (0, _asyncToGenerator2.default)(function* ({
    parentSpan
  }) {
    const spanArgs = parentSpan ? {
      childOf: parentSpan
    } : {};
    const span = tracer.startSpan(`build schema`, spanArgs);

    const types = _.groupBy(getNodes().filter(node => node.internal && !node.internal.ignoreType), node => node.internal.type);

    const processedTypes = {};
    clearTypeExampleValues(); // Reset stored File type to not point to outdated type definition

    setFileNodeRootType(null);

    function createNodeFields(type) {
      const defaultNodeFields = {
        id: {
          type: new GraphQLNonNull(GraphQLID),
          description: `The id of this node.`
        },
        parent: {
          type: nodeInterface,
          description: `The parent of this node.`,
          resolve: pageDependencyResolver(node => getNode(node.parent))
        },
        children: {
          type: new GraphQLList(nodeInterface),
          description: `The children of this node.`,
          resolve: pageDependencyResolver(node => node.children.map(getNode))
        } // Create children fields for each type of children e.g.
        // "childrenMarkdownRemark".

      };

      const childNodesByType = _(type.nodes).flatMap(({
        children
      }) => children.map(getNode)).groupBy(node => node.internal ? _.camelCase(node.internal.type) : undefined).value();

      Object.keys(childNodesByType).forEach(childNodeType => {
        // Does this child type have one child per parent or multiple?
        const maxChildCount = _.maxBy(_.values(_.groupBy(childNodesByType[childNodeType], c => c.parent)), g => g.length).length;

        if (maxChildCount > 1) {
          defaultNodeFields[_.camelCase(`children ${childNodeType}`)] = {
            type: new GraphQLList(processedTypes[childNodeType].nodeObjectType),
            description: `The children of this node of type ${childNodeType}`,
            resolve: pageDependencyResolver(node => node.children.map(getNode).filter(node => _.camelCase(node.internal.type) === childNodeType))
          };
        } else {
          defaultNodeFields[_.camelCase(`child ${childNodeType}`)] = {
            type: processedTypes[childNodeType].nodeObjectType,
            description: `The child of this node of type ${childNodeType}`,
            resolve: pageDependencyResolver(node => node.children.map(getNode).find(node => _.camelCase(node.internal.type) === childNodeType))
          };
        }
      });
      const inferredFields = inferObjectStructureFromNodes({
        nodes: type.nodes,
        types: _.values(processedTypes),
        ignoreFields: Object.keys(type.fieldsFromPlugins)
      });
      return Object.assign({}, defaultNodeFields, inferredFields, type.fieldsFromPlugins);
    }

    function createType(_x2, _x3) {
      return _createType.apply(this, arguments);
    } // Create node types and node fields for nodes that have a resolve function.


    function _createType() {
      _createType = (0, _asyncToGenerator2.default)(function* (nodes, typeName) {
        const intermediateType = {};
        intermediateType.name = typeName;
        intermediateType.nodes = nodes;
        const fieldsFromPlugins = yield apiRunner(`setFieldsOnGraphQLNodeType`, {
          type: intermediateType,
          traceId: `initial-setFieldsOnGraphQLNodeType`,
          parentSpan: span
        });

        const mergedFieldsFromPlugins = _.merge(...fieldsFromPlugins);

        const inferredInputFieldsFromPlugins = inferInputObjectStructureFromFields({
          fields: mergedFieldsFromPlugins
        });
        const gqlType = new GraphQLObjectType({
          name: typeName,
          description: `Node of type ${typeName}`,
          interfaces: [nodeInterface],
          fields: () => createNodeFields(proccesedType),
          isTypeOf: value => value.internal.type === typeName
        });
        const inferedInputFields = inferInputObjectStructureFromNodes({
          nodes,
          typeName
        });

        const filterFields = _.merge({}, inferedInputFields.inferredFields, inferredInputFieldsFromPlugins.inferredFields);

        const proccesedType = Object.assign({}, intermediateType, {
          fieldsFromPlugins: mergedFieldsFromPlugins,
          nodeObjectType: gqlType,
          node: {
            name: typeName,
            type: gqlType,
            args: filterFields,
            resolve: pageDependencyResolver(
            /*#__PURE__*/
            function () {
              var _ref2 = (0, _asyncToGenerator2.default)(function* (a, queryArgs) {
                if (!_.isObject(queryArgs)) {
                  queryArgs = {};
                }

                const results = yield runQuery({
                  queryArgs: {
                    filter: Object.assign({}, queryArgs)
                  },
                  firstOnly: true,
                  gqlType
                });

                if (results.length > 0) {
                  return results[0];
                } else {
                  return null;
                }
              });

              return function (_x4, _x5) {
                return _ref2.apply(this, arguments);
              };
            }())
          }
        });
        processedTypes[_.camelCase(typeName)] = proccesedType; // Special case to construct linked file type used by type inferring

        if (typeName === `File`) {
          setFileNodeRootType(gqlType);
        }
      });
      return _createType.apply(this, arguments);
    }

    yield Promise.all(_.map(types, createType));
    span.finish();
    return processedTypes;
  });

  return function (_x) {
    return _ref.apply(this, arguments);
  };
}();
//# sourceMappingURL=build-node-types.js.map