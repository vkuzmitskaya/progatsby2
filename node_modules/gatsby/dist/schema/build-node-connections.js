"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

const _ = require(`lodash`);

const _require = require(`graphql-skip-limit`),
      connectionArgs = _require.connectionArgs,
      connectionDefinitions = _require.connectionDefinitions;

const _require2 = require(`graphql`),
      GraphQLInputObjectType = _require2.GraphQLInputObjectType;

const _require3 = require(`./infer-graphql-input-fields`),
      inferInputObjectStructureFromNodes = _require3.inferInputObjectStructureFromNodes;

const _require4 = require(`./infer-graphql-input-fields-from-fields`),
      inferInputObjectStructureFromFields = _require4.inferInputObjectStructureFromFields;

const createSortField = require(`./create-sort-field`);

const buildConnectionFields = require(`./build-connection-fields`);

const createPageDependency = require(`../redux/actions/add-page-dependency`);

const _require5 = require(`graphql-skip-limit`),
      connectionFromArray = _require5.connectionFromArray;

const _require6 = require(`../db/nodes`),
      runQuery = _require6.runQuery;

function handleQueryResult({
  results,
  queryArgs,
  path
}) {
  if (results && results.length) {
    const connection = connectionFromArray(results, queryArgs);
    connection.totalCount = results.length;

    if (results[0].internal) {
      const connectionType = connection.edges[0].node.internal.type;
      createPageDependency({
        path,
        connection: connectionType
      });
    }

    return connection;
  } else {
    return null;
  }
}

module.exports = types => {
  const connections = {};

  _.each(types, (type
  /* , fieldName*/
  ) => {
    // Don't create a connection for the Site node since there can only be one
    // of them.
    if (type.name === `Site`) {
      return;
    }

    const nodes = type.nodes;
    const typeName = `${type.name}Connection`;

    const _connectionDefinition = connectionDefinitions({
      nodeType: type.nodeObjectType,
      connectionFields: () => buildConnectionFields(type)
    }),
          typeConnection = _connectionDefinition.connectionType;

    const inferredInputFieldsFromNodes = inferInputObjectStructureFromNodes({
      nodes,
      typeName
    });
    const inferredInputFieldsFromPlugins = inferInputObjectStructureFromFields({
      fields: type.fieldsFromPlugins,
      typeName
    });

    const filterFields = _.merge({}, inferredInputFieldsFromNodes.inferredFields, inferredInputFieldsFromPlugins.inferredFields);

    const sortNames = inferredInputFieldsFromNodes.sort.concat(inferredInputFieldsFromPlugins.sort);
    const sort = createSortField(typeName, sortNames);
    connections[_.camelCase(`all ${type.name}`)] = {
      type: typeConnection,
      description: `Connection to all ${type.name} nodes`,
      args: Object.assign({}, connectionArgs, {
        sort,
        filter: {
          type: new GraphQLInputObjectType({
            name: _.camelCase(`filter ${type.name}`),
            description: `Filter connection on its fields`,
            fields: () => filterFields
          })
        }
      }),

      resolve(object, queryArgs, b, {
        rootValue
      }) {
        return (0, _asyncToGenerator2.default)(function* () {
          let path;

          if (typeof rootValue !== `undefined`) {
            path = rootValue.path;
          }

          const results = yield runQuery({
            queryArgs,
            firstOnly: false,
            gqlType: type.node.type
          });
          return handleQueryResult({
            results,
            queryArgs,
            path
          });
        })();
      }

    };
  });

  return connections;
};
//# sourceMappingURL=build-node-connections.js.map